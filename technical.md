# Technical Skills

Necessary technical skills vary widely by discipline and company need. 

## Levels

1. Familiar, has completed tutorials or personal projects.
2. Completed bugs or small features for professional or open source project.
3. Completed large features with major user impact for professional or open source project.
4. Technical lead for a major contribution to a professional or open source project. 
5. Technical lead for entire professional product or open source project. 

## Programming Language

 * Main language used by team almost every day.
     * They would use this language almost every day.
 * Similar to language used by team
     * A similar language to the one used by the team (ie Main is Ruby but they know Python or Golang)
 * Sometimes language used by team
     * They would use this language only on certain assignments or rarely
 * Major supporting tools used by team 
     * Major library or API used by team (ie, SqlAlchemy or Stripe)
 * Not used by the team, but desired for a new project.
     * This would be used in a new project if anyone knew how to use it.

## Interface 

* Created interfaces that are accessible.
    * [w3c criteria](https://www.w3.org/standards/webdesign/accessibility)
* Created interfaces that are compatible across desired devices.
* Created interfaces that are clear and easy-to-use for clients.

## Infrastructure

* Created and maintained infrastructure in a cloud service.
    * Fill in desired one.
* Created and maintained programmatic infrastructure.
* Created and maintained deployment pipeline.
* Created and maintained automation for infrastructure.

## Problem Solving

* Created solutions for the short, mid and long term.
* Balanced creative and practical solutions.
* Tracked down an error in production, reported by user.
* Tracked down an error in production, reported by alerts.
* Broke down a large task into smaller tasks.
* Broke down a large task into parallel tasks and managed completion.
    * Tasks were completed by multiple people simultaneously.
* Generally can estimate task completion time, factoring in for unknowns.

## System Design

* Designed for simplicity.
    * Less moving parts, less parts to break.
* Designed to scale to right size number of users.
    * Not all projects are going to have a million users, so scaled to probable size.
* Designed to recover from chaotic failures.
* Designed to minimize costs.
* Designed with correct alerting
    * The right failures get through without too many false positives.
* Designed to be transparent.
    * The midnight rule. Can be triaged at midnight by someone who does not have to call you. 
* Designed to be maintainable.
    * The bus rule. If you were hit by a bus, could another person pick up the project?

## Testing

* Manually tested.
* Created unit tests.
* Created and maintained adequate test coverage.
* Created user story test cases.
* Created integration tests.
* Created an environment to match production for testings.
* Automated testing with every deployment.

## Documentation

* Wrote in code documentation.
* Wrote outside code documentation.
* Created flowcharts and diagrams for documentation. 
* Wrote documentation for different users.
    * For example, one for engineers, one for users.
* Wrote tutorials and common usage.
